#lang racket

(require "helper.rkt" "interp.rkt")
(require "parse.rkt" "uniquify.rkt")

(test MTR/interp
 `(,identity ,parse)

 `(program () 41)
 `(program () #t)
 `(program () #f)
 `(program () (read))
 `(program () (void))
 `(program () (let ([x 42]) x))
 `(program () (if #t 42 24))
 `(program () (- 42))
 `(program () (+ 42 24))
 `(program () (- 42 24))
 `(program () (* 42 24))
 `(program () (/ 42 24))
 `(program () (and #t #f))
 `(program () (or #t #f))
 `(program () (not #t))
 `(program () (eq? 42 24))
 `(program () (eq? #t #f))
 `(program () (< 42 24))
 `(program () (> 39 24))
 `(program () (<= 42 24))
 `(program () (>= 42 24))
 `(program () (vector 42 #t))
 `(program () (vector (vector 1 2) (vector #t #f)))
 `(program () (vector-ref (vector 42 #t) 0))
 `(program () (vector-set! (vector 42 #t) 1 24))
 `(program () (lambda ([a1 : Integer]) : Integer (+ a1 10)))
 `(program () (let ([x (lambda ([a1 : Integer]) : Integer (+ a1 10))]) (x 20)))
 `(program ()
    (define (aaa [a1 : Integer]) : Integer (+ 10 a1))
    (define (bbb [b1 : Integer]) : Integer (+ (aaa 10) b1)) 
    (define (ccc [c1 : Integer]) : Integer (+ 20 c1))
    (define (ddd [d1 : (Integer -> Integer)]
                 [d2 : (Integer -> Integer)])
            : (Vector Integer Integer)
      (vector (d1 30) (d2 40)))
    (ddd bbb ccc))
 )

